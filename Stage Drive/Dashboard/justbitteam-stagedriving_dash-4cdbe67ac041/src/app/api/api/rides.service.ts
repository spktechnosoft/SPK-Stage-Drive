/**
 * Stage Driving API
 * API specifications
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { AccountDTO } from '../model/accountDTO';
import { RideDTO } from '../model/rideDTO';
import { RidePassengerDTO } from '../model/ridePassengerDTO';
import { StgdrvResponseDTO } from '../model/stgdrvResponseDTO';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class RidesService {

    protected basePath = 'http://localhost';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Add passenger to this ride
     * Add passenger to this ride
     * @param body 
     * @param rideId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addPassengerToRide(body: RidePassengerDTO, rideId: string, observe?: 'body', reportProgress?: boolean): Observable<StgdrvResponseDTO>;
    public addPassengerToRide(body: RidePassengerDTO, rideId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<StgdrvResponseDTO>>;
    public addPassengerToRide(body: RidePassengerDTO, rideId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<StgdrvResponseDTO>>;
    public addPassengerToRide(body: RidePassengerDTO, rideId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addPassengerToRide.');
        }
        if (rideId === null || rideId === undefined) {
            throw new Error('Required parameter rideId was null or undefined when calling addPassengerToRide.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<StgdrvResponseDTO>(`${this.basePath}/v1/rides/${encodeURIComponent(String(rideId))}/passengers`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * New ride
     * New ride
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addRide(body: RideDTO, observe?: 'body', reportProgress?: boolean): Observable<StgdrvResponseDTO>;
    public addRide(body: RideDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<StgdrvResponseDTO>>;
    public addRide(body: RideDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<StgdrvResponseDTO>>;
    public addRide(body: RideDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addRide.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<StgdrvResponseDTO>(`${this.basePath}/v1/rides`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete passenger to this ride
     * Delete passenger to this ride
     * @param passengerId 
     * @param rideId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deletePassengerToRide(passengerId: string, rideId: string, observe?: 'body', reportProgress?: boolean): Observable<StgdrvResponseDTO>;
    public deletePassengerToRide(passengerId: string, rideId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<StgdrvResponseDTO>>;
    public deletePassengerToRide(passengerId: string, rideId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<StgdrvResponseDTO>>;
    public deletePassengerToRide(passengerId: string, rideId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (passengerId === null || passengerId === undefined) {
            throw new Error('Required parameter passengerId was null or undefined when calling deletePassengerToRide.');
        }
        if (rideId === null || rideId === undefined) {
            throw new Error('Required parameter rideId was null or undefined when calling deletePassengerToRide.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<StgdrvResponseDTO>(`${this.basePath}/v1/rides/${encodeURIComponent(String(rideId))}/passengers/${encodeURIComponent(String(passengerId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete ride
     * Delete ride
     * @param rideId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteRide(rideId: string, observe?: 'body', reportProgress?: boolean): Observable<StgdrvResponseDTO>;
    public deleteRide(rideId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<StgdrvResponseDTO>>;
    public deleteRide(rideId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<StgdrvResponseDTO>>;
    public deleteRide(rideId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (rideId === null || rideId === undefined) {
            throw new Error('Required parameter rideId was null or undefined when calling deleteRide.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.delete<StgdrvResponseDTO>(`${this.basePath}/v1/rides/${encodeURIComponent(String(rideId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Edit ride
     * Edit ride
     * @param body 
     * @param rideId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public editRide(body: RideDTO, rideId: string, observe?: 'body', reportProgress?: boolean): Observable<StgdrvResponseDTO>;
    public editRide(body: RideDTO, rideId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<StgdrvResponseDTO>>;
    public editRide(body: RideDTO, rideId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<StgdrvResponseDTO>>;
    public editRide(body: RideDTO, rideId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling editRide.');
        }
        if (rideId === null || rideId === undefined) {
            throw new Error('Required parameter rideId was null or undefined when calling editRide.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.put<StgdrvResponseDTO>(`${this.basePath}/v1/rides/${encodeURIComponent(String(rideId))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete passenger to this ride
     * Delete passenger to this ride
     * @param passengerId 
     * @param rideId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPassenger(passengerId: string, rideId: string, observe?: 'body', reportProgress?: boolean): Observable<StgdrvResponseDTO>;
    public getPassenger(passengerId: string, rideId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<StgdrvResponseDTO>>;
    public getPassenger(passengerId: string, rideId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<StgdrvResponseDTO>>;
    public getPassenger(passengerId: string, rideId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (passengerId === null || passengerId === undefined) {
            throw new Error('Required parameter passengerId was null or undefined when calling getPassenger.');
        }
        if (rideId === null || rideId === undefined) {
            throw new Error('Required parameter rideId was null or undefined when calling getPassenger.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<StgdrvResponseDTO>(`${this.basePath}/v1/rides/${encodeURIComponent(String(rideId))}/passengers/${encodeURIComponent(String(passengerId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get passengers of this ride
     * Get passengers of this ride
     * @param rideId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPassengerOfRide(rideId: string, observe?: 'body', reportProgress?: boolean): Observable<Array<AccountDTO>>;
    public getPassengerOfRide(rideId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<AccountDTO>>>;
    public getPassengerOfRide(rideId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<AccountDTO>>>;
    public getPassengerOfRide(rideId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (rideId === null || rideId === undefined) {
            throw new Error('Required parameter rideId was null or undefined when calling getPassengerOfRide.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Array<AccountDTO>>(`${this.basePath}/v1/rides/${encodeURIComponent(String(rideId))}/passengers`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve ride
     * Retrieve ride
     * @param rideId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRide(rideId: string, observe?: 'body', reportProgress?: boolean): Observable<RideDTO>;
    public getRide(rideId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RideDTO>>;
    public getRide(rideId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RideDTO>>;
    public getRide(rideId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (rideId === null || rideId === undefined) {
            throw new Error('Required parameter rideId was null or undefined when calling getRide.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<RideDTO>(`${this.basePath}/v1/rides/${encodeURIComponent(String(rideId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves rides
     * Retrieves rides
     * @param fromCoordinate From coordinate (lat,comma,lon without brackets)
     * @param toCoordinate To coordinate (lat,comma,lon without brackets)
     * @param distance Coordinate max distance
     * @param fromEventId From Event Id
     * @param toEventId To Event Id
     * @param goingDepartureDate Going departure date
     * @param goingArrivalDate Going arrival date
     * @param returnDepartureDate Return departure date
     * @param returnArrivalDate Return arrival date
     * @param eventId The rides associated with the event
     * @param withTickets Ride with tickets
     * @param withBookings Ride with bookings
     * @param withFriends Ride with friends
     * @param hasReturn Ride with return
     * @param filter Ride filters
     * @param accountId Account id
     * @param availableSeats Number of available seats
     * @param bookedSeats Number of booked seats
     * @param price Maximum price
     * @param price2 Maximum total price
     * @param order Order
     * @param sort Sort
     * @param idLike Id like
     * @param fromEventIdLike From Event Id like
     * @param toEventIdLike To Event Id like
     * @param size Size
     * @param limit Response page size
     * @param page Response page index
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRides(fromCoordinate?: string, toCoordinate?: string, distance?: number, fromEventId?: string, toEventId?: string, goingDepartureDate?: string, goingArrivalDate?: string, returnDepartureDate?: string, returnArrivalDate?: string, eventId?: string, withTickets?: boolean, withBookings?: boolean, withFriends?: boolean, hasReturn?: boolean, filter?: string, accountId?: string, availableSeats?: number, bookedSeats?: number, price?: number, price2?: number, order?: string, sort?: string, idLike?: string, fromEventIdLike?: string, toEventIdLike?: string, size?: boolean, limit?: number, page?: number, observe?: 'body', reportProgress?: boolean): Observable<Array<RideDTO>>;
    public getRides(fromCoordinate?: string, toCoordinate?: string, distance?: number, fromEventId?: string, toEventId?: string, goingDepartureDate?: string, goingArrivalDate?: string, returnDepartureDate?: string, returnArrivalDate?: string, eventId?: string, withTickets?: boolean, withBookings?: boolean, withFriends?: boolean, hasReturn?: boolean, filter?: string, accountId?: string, availableSeats?: number, bookedSeats?: number, price?: number, price2?: number, order?: string, sort?: string, idLike?: string, fromEventIdLike?: string, toEventIdLike?: string, size?: boolean, limit?: number, page?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RideDTO>>>;
    public getRides(fromCoordinate?: string, toCoordinate?: string, distance?: number, fromEventId?: string, toEventId?: string, goingDepartureDate?: string, goingArrivalDate?: string, returnDepartureDate?: string, returnArrivalDate?: string, eventId?: string, withTickets?: boolean, withBookings?: boolean, withFriends?: boolean, hasReturn?: boolean, filter?: string, accountId?: string, availableSeats?: number, bookedSeats?: number, price?: number, price2?: number, order?: string, sort?: string, idLike?: string, fromEventIdLike?: string, toEventIdLike?: string, size?: boolean, limit?: number, page?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RideDTO>>>;
    public getRides(fromCoordinate?: string, toCoordinate?: string, distance?: number, fromEventId?: string, toEventId?: string, goingDepartureDate?: string, goingArrivalDate?: string, returnDepartureDate?: string, returnArrivalDate?: string, eventId?: string, withTickets?: boolean, withBookings?: boolean, withFriends?: boolean, hasReturn?: boolean, filter?: string, accountId?: string, availableSeats?: number, bookedSeats?: number, price?: number, price2?: number, order?: string, sort?: string, idLike?: string, fromEventIdLike?: string, toEventIdLike?: string, size?: boolean, limit?: number, page?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (fromCoordinate !== undefined) {
            queryParameters = queryParameters.set('fromCoordinate', <any>fromCoordinate);
        }
        if (toCoordinate !== undefined) {
            queryParameters = queryParameters.set('toCoordinate', <any>toCoordinate);
        }
        if (distance !== undefined) {
            queryParameters = queryParameters.set('distance', <any>distance);
        }
        if (fromEventId !== undefined) {
            queryParameters = queryParameters.set('fromEventId', <any>fromEventId);
        }
        if (toEventId !== undefined) {
            queryParameters = queryParameters.set('toEventId', <any>toEventId);
        }
        if (goingDepartureDate !== undefined) {
            queryParameters = queryParameters.set('goingDepartureDate', <any>goingDepartureDate);
        }
        if (goingArrivalDate !== undefined) {
            queryParameters = queryParameters.set('goingArrivalDate', <any>goingArrivalDate);
        }
        if (returnDepartureDate !== undefined) {
            queryParameters = queryParameters.set('returnDepartureDate', <any>returnDepartureDate);
        }
        if (returnArrivalDate !== undefined) {
            queryParameters = queryParameters.set('returnArrivalDate', <any>returnArrivalDate);
        }
        if (eventId !== undefined) {
            queryParameters = queryParameters.set('eventId', <any>eventId);
        }
        if (withTickets !== undefined) {
            queryParameters = queryParameters.set('withTickets', <any>withTickets);
        }
        if (withBookings !== undefined) {
            queryParameters = queryParameters.set('withBookings', <any>withBookings);
        }
        if (withFriends !== undefined) {
            queryParameters = queryParameters.set('withFriends', <any>withFriends);
        }
        if (hasReturn !== undefined) {
            queryParameters = queryParameters.set('hasReturn', <any>hasReturn);
        }
        if (filter !== undefined) {
            queryParameters = queryParameters.set('filter', <any>filter);
        }
        if (accountId !== undefined) {
            queryParameters = queryParameters.set('accountId', <any>accountId);
        }
        if (availableSeats !== undefined) {
            queryParameters = queryParameters.set('availableSeats', <any>availableSeats);
        }
        if (bookedSeats !== undefined) {
            queryParameters = queryParameters.set('bookedSeats', <any>bookedSeats);
        }
        if (price !== undefined) {
            queryParameters = queryParameters.set('price', <any>price);
        }
        if (price2 !== undefined) {
            queryParameters = queryParameters.set('price', <any>price2);
        }
        if (order !== undefined) {
            queryParameters = queryParameters.set('order', <any>order);
        }
        if (sort !== undefined) {
            queryParameters = queryParameters.set('sort', <any>sort);
        }
        if (idLike !== undefined) {
            queryParameters = queryParameters.set('id_like', <any>idLike);
        }
        if (fromEventIdLike !== undefined) {
            queryParameters = queryParameters.set('fromEventId_like', <any>fromEventIdLike);
        }
        if (toEventIdLike !== undefined) {
            queryParameters = queryParameters.set('toEventId_like', <any>toEventIdLike);
        }
        if (size !== undefined) {
            queryParameters = queryParameters.set('size', <any>size);
        }
        if (limit !== undefined) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (page !== undefined) {
            queryParameters = queryParameters.set('page', <any>page);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<Array<RideDTO>>(`${this.basePath}/v1/rides`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
